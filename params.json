{"name":"Cyclops","tagline":"Modular extensions for Java 8 awesomeness","body":"# Cyclops\r\n\r\nPowerful, modular extensions for Java 8. Take what you need / want.\r\n\r\n* [Extensible For Comprehensions](https://github.com/aol/cyclops/wiki/Extensible-For-Comprehensions-for-Java-8)\r\n* [Pattern Matching](https://github.com/aol/cyclops/wiki/Pattern-matching-:-Pattern-Matching-for-Java-8)\r\n* [Advanced Monadic (Stream, Optional etc) cross-type operations](https://github.com/aol/cyclops/wiki/Monad-&-Stream-utilities)\r\n* [Powerful Tuple implementation](https://github.com/aol/cyclops/wiki/Power-Tuples)\r\n* [Trampoline](https://github.com/aol/cyclops/wiki/Trampoline-:-Stackless-Recursion-for-Java-8)\r\n* [Try](https://github.com/aol/cyclops/wiki/Try-:-functional-exception-handling-for-Java-8)\r\n* [Enable Switch](https://github.com/aol/cyclops/wiki/Enable-and-disable-production-features)\r\n* [Utils for working with Functions](https://github.com/aol/cyclops/wiki/Utilities-for-working-with-Java-8-Functions)\r\n\r\n\r\n[Cyclops Wiki](https://github.com/aol/cyclops/wiki)\r\n\r\n\r\n## For Comprehensions\r\n\r\nPerform nested operations on Collections or Monads.\r\n\r\n![for comprehensions](https://cloud.githubusercontent.com/assets/9964792/7887680/c6ac127c-062a-11e5-9ad7-ad4553761e8d.png)\r\n\r\n### Example \r\n\r\n    Stream<Double> s = Do.with(asList(10.00,5.00,100.30))\r\n\t\t\t\t\t\t.with(asList(2.0))\r\n\t\t\t\t\t\t.and((Double d)->(Double e)->asList(e*d*10.0))\r\n\t\t\t\t\t\t.yield((Double i)->(Double j)->(Double k) -> i*(1.0+j)*k);\r\n\t\t\r\n\tdouble total = s.collect(Collectors.summingDouble(t->t));\r\n\r\n## Pattern Matching\r\n\r\nAdvanced Scala-like pattern matching for Java 8. Match recursively against most Objects / datastructures.\r\n\r\n![whenvalues recursive](https://cloud.githubusercontent.com/assets/9964792/7887716/01eeeeb8-062b-11e5-95e9-3ac10f16acdf.png)\r\n\r\nFeatures include\r\n\r\n* Sequential, Parallel and Async execution\r\n* Match by type, value, predicate or Hamcrest Matcher\r\n* Recursively decompose and match against Case classes\r\n* Fluent step builders for common cases\r\n* Fluent, functionally compositional monad-like core Case and Cases classes\r\n* Support for chain of responsibility pattern within a Stream\r\n* Support hamcrest matchers\r\n* Java 8 predicates for matching.\r\n* Match on first (return Optional)\r\n* Match many (return Stream)\r\n* Strict and lose typing\r\n* Pre & post value extraction per case\r\n* Match using multiple in case expressions via tuples or iterables of predicates / matchers\r\n* Match against streams of data\r\n* Usable within a Stream (strategy pattern)\r\n* Fluent step builders\r\n\r\n### Example \r\n\r\n    private <I,T> CheckValues<Object, T> cases(CheckValues<I, T> c) {\r\n\t\treturn c.with(1,2,3).then(i->\"hello\")\r\n\t\t\t\t.with(4,5,6).then(i->\"goodbye\");\r\n\t}\r\n\t@Test\r\n\tpublic void test(){\r\n\t\tassertThat(As.asMatchable(new MyCase(1,2,3)).match(this::cases),equalTo(\"hello\"));\r\n\t\t\r\n\t}\r\n\r\n## Extensible Generic Monad Operations\r\n\r\n### Example\r\n\r\nflatMap (bind) across Stream and Optional types (null entries are removed)\r\n\r\n      List<Integer> list = As.<Stream<Integer>,List<Integer>>asMonad(Stream.of(Arrays.asList(1,3),null))\r\n\t\t\t\t.bind(Optional::ofNullable)\r\n\t\t\t\t.map(i->i.size())\r\n\t\t\t\t.peek(System.out::println)\r\n\t\t\t\t.toList();\r\n\t\tassertThat(Arrays.asList(2),equalTo(list));\r\n\r\n### Example\r\n\r\nLift a File to a Stream\r\n\r\n\r\n\t\tList<String> result = AsGenericMonad.<Stream<String>,String>asMonad(Stream.of(\"input.file\"))\r\n\t\t\t\t\t\t\t\t.map(getClass().getClassLoader()::getResource)\r\n\t\t\t\t\t\t\t\t.peek(System.out::println)\r\n\t\t\t\t\t\t\t\t.map(URL::getFile)\r\n\t\t\t\t\t\t\t\t.<Stream<String>,String>liftAndbind(File::new)\r\n\t\t\t\t\t\t\t\t.toList();\r\n\t\t\r\n\t\tassertThat(result,equalTo(Arrays.asList(\"hello\",\"world\")));\r\n\r\n## Power Tuples \r\n\r\nFeatures include\r\n\r\n* Wrap any Tuple type / Object (mapping fields to elements and back)\r\n* Method call chaining support\r\n* Asyncrhonous method call chaining support\r\n* Inheritance relationship between Tuples\r\n* Lazy and Strict map methods\r\n* Lazy reordering\r\n* Pattern matching\r\n* For comprehensions\r\n* Useful utility methods (asStreamOfStrings, asTwoNumbers etc)\r\n* Concatonation\r\n* LazySwap (reverse)\r\nvMemoization\r\n* asCollector\r\n* asReducer\r\n\r\n[See Power Tuples wiki](https://github.com/aol/cyclops/wiki/Power-Tuples)\r\n\r\n## Stackless Recursion with Trampoline\r\n\r\nUtilise the heap rather than the Stack for (tail) recursive algorithms in Java.\r\n   \r\n The Java code below will result in a Stackoverflow error  \r\n   \r\n    @Test @Ignore\r\n\tpublic void trampolineTest1(){\r\n\t\t\r\n\t\tassertThat(loop1(500000,10),equalTo(446198426));\r\n\t\t\r\n\t}\r\n\tInteger loop1(int times,int sum){\r\n\t\t\r\n\t\tif(times==0)\r\n\t\t\treturn sum;\r\n\t\telse\r\n\t\t\treturn loop1(times-1,sum+times);\r\n\t}  \r\n\r\nThe same code using Trampoline works fine.\r\n\r\n\r\n    @Test\r\n    public void trampolineTest(){\r\n\r\n        assertThat(loop(500000,10).result(),equalTo(446198426));\r\n\r\n     }\r\n\r\n     Trampoline<Integer> loop(int times,int sum){\r\n       \r\n       if(times==0)\r\n          return Trampoline.done(sum);\r\n       else\r\n          return Trampoline.more(()->loop(times-1,sum+times));\r\n     }\r\n     \r\n## Try : functional exception handling\r\n\r\nCyclops Try is similar to, but functionally different from the Scala (and JAVASLANG) Try monads. \r\n\r\nFeatures \r\n\r\n* Try with Resources\r\n* Success and Failure states\r\n* Step builders to guide you through use\r\n* Catch specified (expected) exceptions\r\n* Doesn't operate as a 'catch-all' that may hide bugs\r\n* Recover from different exceptions independently\r\n* Functional composition over both success and failed states\r\n\r\n\r\n### Example : Try with resources\r\n\r\n    Try.catchExceptions(FileNotFoundException.class,IOException.class)\r\n\t\t\t\t   .init(()->new BufferedReader(new FileReader(\"file.txt\")))\r\n\t\t\t\t   .tryWithResources(this::read)\r\n\t\t\t\t   .onFail(this::recover)\r\n\t\t\t\t   .map(this::continueProcessing)\r\n\t\t\t\t\r\n## Production Enable / Disable Switch\r\n\r\n* Enable / Disable classes (Pattern Match by type)\r\n* convert to Optional or Stream\r\n* standard Java 8 operators (map, flatMap, peek, filter, forEach) + flatten etc\r\n* isEnabled / isDisabled\r\n* Biased towards enabled (right biased).\r\n\r\n### Example\r\n\r\n\tSwitch<Feature> switch = createSwitch(config);\r\n\t\r\n    switch.map(this::processData); //if live, data is processed, otherwise nothing happens\r\n    \r\n\r\n## Traits\r\n\r\n* Decomposable : decompose an Object to a Iterable over it's values\r\n* Matchable : add pattern matching capabilities to an Object\r\n* Doable : add for comprehension capabilities to an Object\r\n* Streamable : add repeatable Streaming capabilities\r\n* Mappable : add the ability to coerce an Object to a map\r\n* Printable : ability to println as an expression\r\n* ValueObject : Matchable and Decomposable object\r\n* StreamableValue : Streamable and Doable ValueObject\r\n\r\ncom.aol.cyclops.dynamic.As offers duck typing / coercion to many different types (including the above traits) and\r\n\r\n* com.aol.cyclops.lambda.monads.Monad\r\n* com.aol.cyclops.lambda.monads.Functor\r\n* com.aol.cyclops.lambda.monads.Monoid\r\n* Supplier\r\n\r\n## Function utilities\r\n\r\n* Currying : com.aol.cyclops.functions.Curry\r\n* Currying for Consumers : com.aol.cyclops.functions.CurryConsumer\r\n* Uncurrying : com.aol.cyclops.functions.Uncurry\r\n* Uncurrying for Consumers : com.aol.cyclops.functions.UncurryConsumer\r\n* Type Inferencing help : com.aol.cyclops.lambda.utils.Lambda\r\n* Memoisation : com.aol.cyclops.functions.Memoise\r\n\r\n## cyclops-base\r\n\r\n### LazyImmutable\r\n\r\nThis is a class that helps work around the limitations of Java 8 lambda expressions as closures. In particular the workings of 'effectively final'.\r\n\r\nLazyImmutable allows a capture value to be set exactly once\r\n\r\nE.g. from cyclops-pattern-matching the code to make an Extractor memoised ->\r\n\r\n    public static final <T,R > Extractor<T,R> memoised( Extractor<T,R> extractor){\r\n\t\tfinal LazyImmutable<R> value = new LazyImmutable<>();\r\n\t\treturn input -> {\r\n\t\t\treturn value.computeIfAbsent(()->extractor.apply(input));\r\n\t\t\t\t\r\n\t\t};\r\n\t\t\r\n\t}\r\n\r\ncomputeIfAbsent is used to extract the value from the LazyImmutable, and takes a Supplier as an argument. The Supplier is only invoked once (the first time).\r\n\r\n### Mutable\r\n\r\nMutable represents a captured variable inside a Java 8 closure. Because of the effectively final rule we can't access variables from within a Closure, but we can mutate the state of captured Objects. Mutable holds a value we would like mutate (if really, really, neccessary)\r\n\r\n     Mutable<Integer> timesCalled = Mutable.of(0);\r\n     Function<String,String> fn = input -> {\r\n     \t\t\treturn input + timesCalled.mutate(v -> v+1);\r\n     }\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}